"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2520],{65071:function(t,r,e){e.d(r,{c:function(){return n}});var a=e(85982),i=e(16810);function n(t){return(0,i.i)(t)?a.aY:t}},92645:function(t,r,e){e.d(r,{C:function(){return n}});var a=e(33154),i=e(85982);class n{featureName=i.dm.name;constructor(t){this.contractWrapper=t}async get(){let[t,r]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return i.bI.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:r})}set=(0,a.c)(async t=>{let r=await i.bI.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[r.platform_fee_recipient,r.platform_fee_basis_points]})})}},81437:function(t,r,e){e.d(r,{a:function(){return m},g:function(){return f},h:function(){return p},i:function(){return d},m:function(){return u},v:function(){return l}});var a=e(28410),i=e(92598),n=e(22130),o=e(3247),s=e(85982),c=e(16810);async function d(t,r,i,n,s){try{let c=(await e.e(1787).then(e.t.bind(e,31787,19))).default,d=new a.CH(i,c,t),[p,l]=await Promise.all([d.supportsInterface(o.I),d.supportsInterface(o.a)]);if(p){let o;let c=(await Promise.resolve().then(e.t.bind(e,32557,19))).default,d=new a.CH(i,c,t),p=await d.isApprovedForAll(s,r);if(p)return!0;try{o=await d.getApproved(n)}catch(t){}return o?.toLowerCase()===r.toLowerCase()}if(!l)return console.error("Contract does not implement ERC 1155 or ERC 721."),!1;{let n=(await Promise.resolve().then(e.t.bind(e,10506,19))).default,o=new a.CH(i,n,t);return await o.isApprovedForAll(s,r)}}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function p(t,r,a,i,n){let c=(await e.e(1787).then(e.t.bind(e,31787,19))).default,d=new s.ct(t.getSignerOrProvider(),a,c,t.options,t.storage),[p,l]=await Promise.all([d.read("supportsInterface",[o.I]),d.read("supportsInterface",[o.a])]);if(p){let o=(await Promise.resolve().then(e.t.bind(e,32557,19))).default,c=new s.ct(t.getSignerOrProvider(),a,o,t.options,t.storage),d=await c.read("isApprovedForAll",[n,r]);if(!d){let t=(await c.read("getApproved",[i])).toLowerCase()===r.toLowerCase();t||await c.sendTransaction("setApprovalForAll",[r,!0])}}else if(l){let i=(await Promise.resolve().then(e.t.bind(e,10506,19))).default,o=new s.ct(t.getSignerOrProvider(),a,i,t.options,t.storage),c=await o.read("isApprovedForAll",[n,r]);c||await o.sendTransaction("setApprovalForAll",[r,!0])}else throw Error("Contract must implement ERC 1155 or ERC 721.")}function l(t){(0,n.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,n.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,n.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,n.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,n.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,n.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type&&(0,n.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function u(t,r,e){return{quantity:e.quantityDesired,pricePerToken:e.pricePerToken,currencyContractAddress:e.currency,buyerAddress:e.offeror,quantityDesired:e.quantityWanted,currencyValue:await (0,c.a)(t,e.currency,e.quantityWanted.mul(e.pricePerToken)),listingId:r}}function m(t,r,e){if(e=i.O$.from(e),t=i.O$.from(t),r=i.O$.from(r),t.eq(i.O$.from(0)))return!1;let a=r.sub(t).mul(s.dx).div(t);return a.gte(e)}async function f(t,r,e){let a=[];for(;r-t>o.D;)a.push(e(t,t+o.D-1)),t+=o.D;return a.push(e(t,r-1)),await Promise.all(a)}},39703:function(t,r,e){e.d(r,{M:function(){return b},a:function(){return k},b:function(){return I}});var a,i=e(92598),n=e(28410),o=e(5572),s=e(73760),c=e(22130),d=e(65071),p=e(16810),l=e(95836),u=e(61327),m=e(85982),f=e(81437),g=e(3247),h=e(33154),w=e(51698),y=e(74578),A=e(85089),C=e(64865);let W=y.z.object({assetContractAddress:m.bc,tokenId:m.b9,quantity:m.b9.default(1),currencyContractAddress:m.bc.default(m.aY),pricePerToken:m.cy,startTimestamp:w.R.default(new Date),endTimestamp:w.E,isReservedListing:y.z.boolean().default(!1)}),v=((a={})[a.UNSET=0]="UNSET",a[a.Created=1]="Created",a[a.Completed=2]="Completed",a[a.Cancelled=3]="Cancelled",a[a.Active=4]="Active",a[a.Expired=5]="Expired",a);class b{featureName=m.dj.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new A.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new C.C(this.contractWrapper),this.estimator=new A.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No listings exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllListings",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapListing(t)))}async getAllValid(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No listings exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllValidListings",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapListing(t)))}async getListing(t){let r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){let e=await this.validateListing(i.O$.from(t));if(!e.isReservedListing)throw Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await (0,m.aO)(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(i.O$.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await (0,m.aO)(r)])}async currencyPriceForListing(t,r){let e=await this.validateListing(i.O$.from(t)),a=await (0,m.aO)(r);if(a===e.currencyContractAddress)return e.pricePerToken;let n=await this.isCurrencyApprovedForListing(t,a);if(!n)throw Error(`Currency ${a} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,a])}createListing=(0,h.c)(async t=>{let r=await W.parseAsync(t);await (0,f.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());let e=await (0,l.n)(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),a=await this.contractWrapper.getProvider().getBlock("latest"),n=a.timestamp;return r.startTimestamp.lt(n)&&(r.startTimestamp=i.O$.from(n)),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,d.c)(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>{let r=this.contractWrapper.parseLogs("NewListing",t?.logs);return{id:r[0].args.listingId,receipt:t}}})});createListingsBatch=(0,h.c)(async t=>{let r=(await Promise.all(t.map(t=>this.createListing.prepare(t)))).map(t=>t.encode());return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>{let r=this.contractWrapper.parseLogs("NewListing",t?.logs);return r.map(r=>({id:r.args.listingId,receipt:t}))}})});updateListing=(0,h.c)(async(t,r)=>{let e=await W.parseAsync(r);await (0,f.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());let a=await (0,l.n)(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:(0,d.c)(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>{let r=this.contractWrapper.parseLogs("UpdatedListing",t?.logs);return{id:r[0].args.listingId,receipt:t}}})});cancelListing=(0,h.c)(async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]}));buyFromListing=(0,h.c)(async(t,r,e)=>{e&&(e=await (0,m.aO)(e));let a=await this.validateListing(i.O$.from(t)),{valid:n,error:o}=await this.isStillValidListing(a,r);if(!n)throw Error(`Listing ${t} is no longer valid. ${o}`);let s=e||await this.contractWrapper.getSignerAddress(),c=i.O$.from(r),d=i.O$.from(a.pricePerToken).mul(c),p=await this.contractWrapper.getCallOverrides()||{};return await (0,u.s)(this.contractWrapper,d,a.currencyContractAddress,p),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,s,c,a.currencyContractAddress,d],overrides:p})});approveBuyerForReservedListing=(0,h.c)(async(t,r)=>{let e=await this.isBuyerApprovedForListing(t,r);if(!e)return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]});throw Error(`Buyer ${r} already approved for listing ${t}.`)});revokeBuyerApprovalForReservedListing=(0,h.c)(async(t,r)=>{let e=await this.isBuyerApprovedForListing(t,r);if(e)return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});throw Error(`Buyer ${r} not approved for listing ${t}.`)});approveCurrencyForListing=(0,h.c)(async(t,r,e)=>{let a=await this.validateListing(i.O$.from(t)),n=await (0,m.aO)(r);n===a.currencyContractAddress&&(0,c.Z)(e===a.pricePerToken,"Approving listing currency with a different price.");let o=await this.contractWrapper.read("currencyPriceForListing",[t,n]);return(0,c.Z)(e===o,"Currency already approved with this price."),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,e]})});revokeCurrencyApprovalForListing=(0,h.c)(async(t,r)=>{let e=await this.validateListing(i.O$.from(t)),a=await (0,m.aO)(r);if(a===e.currencyContractAddress)throw Error("Can't revoke approval for main listing currency.");let n=await this.contractWrapper.read("currencyPriceForListing",[t,a]);return(0,c.Z)(!n.isZero(),"Currency not approved."),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,a,i.O$.from(0)]})});async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){let r=v.UNSET,e=await this.contractWrapper.getProvider().getBlock("latest"),a=e.timestamp;switch(t.status){case 1:r=i.O$.from(t.startTimestamp).gt(a)?v.Created:i.O$.from(t.endTimestamp).lt(a)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await (0,p.a)(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:i.O$.from(t.startTimestamp).toNumber(),asset:await (0,g.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:i.O$.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){let a=await (0,f.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress);if(!a)return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};let i=this.contractWrapper.getProvider(),o=(await e.e(1787).then(e.t.bind(e,31787,19))).default,s=new n.CH(t.assetContractAddress,o,i),c=await s.supportsInterface(g.I),d=await s.supportsInterface(g.a);if(c){let r;let a=(await Promise.resolve().then(e.t.bind(e,32557,19))).default,o=new n.CH(t.assetContractAddress,a,i);try{r=await o.ownerOf(t.tokenId)}catch(t){}let s=r?.toLowerCase()===t.creatorAddress.toLowerCase();return{valid:s,error:s?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(!d)return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."};{let a=(await Promise.resolve().then(e.t.bind(e,10506,19))).default,o=new n.CH(t.assetContractAddress,a,i),s=await o.balanceOf(t.creatorAddress,t.tokenId),c=s.gte(r||t.quantity);return{valid:c,error:c?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){let t=await (0,m.aO)(r.seller);e=e.filter(r=>r.listingCreator.toString().toLowerCase()===t?.toString().toLowerCase())}if(r.tokenContract){let t=await (0,m.aO)(r.tokenContract);e=e.filter(r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase())}void 0!==r.tokenId&&(e=e.filter(t=>t.tokenId.toString()===r?.tokenId?.toString()))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}let T=y.z.object({assetContractAddress:m.bc,tokenId:m.b9,quantity:m.b9.default(1),currencyContractAddress:m.bc.default(m.aY),minimumBidAmount:m.cy,buyoutBidAmount:m.cy,timeBufferInSeconds:m.b9.default(900),bidBufferBps:m.b9.default(500),startTimestamp:w.R.default(new Date),endTimestamp:w.E});class k{featureName=m.dk.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new A.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new C.C(this.contractWrapper),this.estimator=new A.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No auctions exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllAuctions",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapAuction(t)))}async getAllValid(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No auctions exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllValidAuctions",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapAuction(t)))}async getAuction(t){let r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(i.O$.from(t));let r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==o.d)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){let r=await this.validateAuction(i.O$.from(t)),e=await this.contractWrapper.read("getWinningBid",[t]),a=i.O$.from(Math.floor(Date.now()/1e3)),n=i.O$.from(r.endTimeInSeconds);if(a.gt(n)&&e._bidder!==o.d)return e._bidder;let s=new A.a(this.contractWrapper),c=await s.getEvents("AuctionClosed"),d=c.find(r=>r.data.auctionId.eq(i.O$.from(t)));if(!d)throw Error(`Could not find auction with ID ${t} in closed auctions`);return d.data.winningBidder}createAuction=(0,h.c)(async t=>{let r=T.parse(t);await (0,f.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());let e=await (0,l.n)(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),a=await (0,l.n)(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),n=await this.contractWrapper.getProvider().getBlock("latest"),o=n.timestamp;return r.startTimestamp.lt(o)&&(r.startTimestamp=i.O$.from(o)),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,d.c)(r.currencyContractAddress),minimumBidAmount:a,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:t=>{let r=this.contractWrapper.parseLogs("NewAuction",t.logs)[0];return{id:r.args.auctionId,receipt:t}}})});createAuctionsBatch=(0,h.c)(async t=>{let r=(await Promise.all(t.map(t=>this.createAuction.prepare(t)))).map(t=>t.encode());return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>{let r=this.contractWrapper.parseLogs("NewAuction",t?.logs);return r.map(r=>({id:r.args.auctionId,receipt:t}))}})});buyoutAuction=(0,h.c)(async t=>{let r=await this.validateAuction(i.O$.from(t)),e=await (0,p.f)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,s.formatUnits(r.buyoutBidAmount,e.decimals))});makeBid=(0,h.c)(async(t,r)=>{let e=await this.validateAuction(i.O$.from(t)),a=await (0,l.n)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(i.O$.from(0)))throw Error("Cannot make a bid with 0 value");if(i.O$.from(e.buyoutBidAmount).gt(0)&&a.gt(e.buyoutBidAmount))throw Error("Bid amount must be less than or equal to buyoutBidAmount");let n=await this.getWinningBid(t);if(n){let r=await this.isWinningBid(t,a);(0,c.Z)(r,"Bid price is too low based on the current winning bid and the bid buffer")}else{let t=i.O$.from(e.minimumBidAmount);(0,c.Z)(a.gte(t),"Bid price is too low based on minimum bid amount")}let o=await this.contractWrapper.getCallOverrides()||{};return await (0,u.s)(this.contractWrapper,a,e.currencyContractAddress,o),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",args:[t,a],overrides:o})});cancelAuction=(0,h.c)(async t=>{let r=await this.getWinningBid(t);if(r)throw Error("Bids already made.");return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]})});closeAuctionForBidder=(0,h.c)(async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());let e=await this.validateAuction(i.O$.from(t));try{return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[i.O$.from(t)]})}catch(r){if(r.message.includes("Marketplace: auction still active."))throw new m.w(t.toString(),e.endTimeInSeconds.toString());throw r}});closeAuctionForSeller=(0,h.c)(async t=>{let r=await this.validateAuction(i.O$.from(t));try{return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[i.O$.from(t)]})}catch(e){if(e.message.includes("Marketplace: auction still active."))throw new m.w(t.toString(),r.endTimeInSeconds.toString());throw e}});executeSale=(0,h.c)(async t=>{let r=await this.validateAuction(i.O$.from(t));try{let r=await this.getWinningBid(t);(0,c.Z)(r,"No winning bid found");let e=this.encoder.encode("collectAuctionPayout",[t]),a=this.encoder.encode("collectAuctionTokens",[t]);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[e,a]]})}catch(e){if(e.message.includes("Marketplace: auction still active."))throw new m.w(t.toString(),r.endTimeInSeconds.toString());throw e}});async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){let[r,e,a]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(i.O$.from(t))]),n=e?i.O$.from(e.bidAmount):i.O$.from(a.minimumBidAmount),o=n.add(n.mul(r).div(1e4));return(0,p.a)(this.contractWrapper.getProvider(),a.currencyContractAddress,o)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error(`Error getting the auction with id ${t}`),r}}async mapAuction(t){let r=v.UNSET,e=await this.contractWrapper.getProvider().getBlock("latest"),a=e.timestamp;switch(t.status){case 1:r=i.O$.from(t.startTimestamp).gt(a)?v.Created:i.O$.from(t.endTimestamp).lt(a)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await (0,p.a)(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await (0,p.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:i.O$.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:i.O$.from(t.bidBufferBps).toNumber(),startTimeInSeconds:i.O$.from(t.startTimestamp).toNumber(),endTimeInSeconds:i.O$.from(t.endTimestamp).toNumber(),asset:await (0,g.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){let i=await (0,m.aO)(r),n=await (0,m.aO)(e);return{auctionId:t,bidderAddress:i,currencyContractAddress:n,bidAmount:a,bidAmountCurrencyValue:await (0,p.a)(this.contractWrapper.getProvider(),n,a)}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){let t=await (0,m.aO)(r.seller);e=e.filter(r=>r.auctionCreator.toString().toLowerCase()===t?.toString().toLowerCase())}if(r.tokenContract){let t=await (0,m.aO)(r.tokenContract);e=e.filter(r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase())}void 0!==r.tokenId&&(e=e.filter(t=>t.tokenId.toString()===r?.tokenId?.toString()))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}let O=y.z.object({assetContractAddress:m.bc,tokenId:m.b9,quantity:m.b9.default(1),currencyContractAddress:m.bc.default(m.aY),totalPrice:m.cy,endTimestamp:w.E});class I{featureName=m.dl.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new A.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new C.C(this.contractWrapper),this.estimator=new A.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No offers exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllOffers",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapOffer(t)))}async getAllValid(t){let r=await this.getTotalCount(),e=i.O$.from(t?.start||0).toNumber(),a=r.toNumber();if(0===a)throw Error("No offers exist on the contract.");let n=[],o=await (0,f.g)(e,a,(t,r)=>this.contractWrapper.read("getAllValidOffers",[t,r]));n=o.flat();let s=await this.applyFilter(n,t);return await Promise.all(s.map(t=>this.mapOffer(t)))}async getOffer(t){let r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}makeOffer=(0,h.c)(async t=>{let r=await O.parseAsync(t),e=await this.contractWrapper.getChainID(),a=(0,p.i)(r.currencyContractAddress)?m.aZ[e].wrapped.address:r.currencyContractAddress,i=await (0,l.n)(this.contractWrapper.getProvider(),r.totalPrice,a),n=await this.contractWrapper.getCallOverrides();return await (0,u.s)(this.contractWrapper,i,a,n),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:i,expirationTimestamp:r.endTimestamp}],parse:t=>{let r=this.contractWrapper.parseLogs("NewOffer",t?.logs);return{id:r[0].args.offerId,receipt:t}}})});cancelOffer=(0,h.c)(async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]}));acceptOffer=(0,h.c)(async t=>{let r=await this.validateOffer(i.O$.from(t)),{valid:e,error:a}=await this.isStillValidOffer(r);if(!e)throw Error(`Offer ${t} is no longer valid. ${a}`);let n=await this.contractWrapper.getCallOverrides()||{};return await (0,f.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:n})});async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error(`Error getting the offer with id ${t}`),r}}async mapOffer(t){let r=v.UNSET,e=await this.contractWrapper.getProvider().getBlock("latest"),a=e.timestamp;switch(t.status){case 1:r=i.O$.from(t.expirationTimestamp).lt(a)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await (0,p.a)(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await (0,g.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:i.O$.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){let r=i.O$.from(Math.floor(Date.now()/1e3));if(r.gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};let a=await this.contractWrapper.getChainID(),n=(0,p.i)(t.currencyContractAddress)?m.aZ[a].wrapped.address:t.currencyContractAddress,o=this.contractWrapper.getProvider(),s=(await Promise.resolve().then(e.t.bind(e,54497,19))).default,c=new m.ct(o,n,s,{},this.storage),d=await c.read("balanceOf",[t.offerorAddress]);if(d.lt(t.totalPrice))return{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${n}`};let l=await c.read("allowance",[t.offerorAddress,this.getAddress()]);return l.lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${n}`}:{valid:!0,error:""}}async applyFilter(t,r){let e=[...t];if(r){if(r.offeror){let t=await (0,m.aO)(r.offeror);e=e.filter(r=>r.offeror.toString().toLowerCase()===t?.toString().toLowerCase())}if(r.tokenContract){let t=await (0,m.aO)(r.tokenContract);e=e.filter(r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase())}void 0!==r.tokenId&&(e=e.filter(t=>t.tokenId.toString()===r?.tokenId?.toString()))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}}}]);